<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <title>Cubo 3D con objetos flotando</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
  </script>
  <style>
    html, body { margin:0; height:100%; overflow:hidden; background:#000; }
    #ui {
      position:fixed; inset:0; display:grid; place-items:center;
      pointer-events:none; color:#fff; font:16px system-ui;
      background: radial-gradient(ellipse at center, #0008 0%, #0000 60%);
    }
    #hint {
      pointer-events:auto; padding:12px 16px; border:1px solid #fff3; border-radius:10px; 
      background:#111a; backdrop-filter: blur(4px);
    }
  </style>
</head>
<body>
  <div id="ui"><div id="hint">Click para entrar • WASD/Flechas para moverse • Espacio/Shift para subir/bajar • Esc para soltar</div></div>

  <script type="module">
    import * as THREE from "three";
    import { PointerLockControls } from "three/addons/controls/PointerLockControls.js";
    import { TextGeometry } from "three/addons/geometries/TextGeometry.js";
    import { FontLoader } from "three/addons/loaders/FontLoader.js";

    const canvasParent = document.body;
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000010, 0.02);

    const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
    camera.position.set(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ antialias:true });
    renderer.setPixelRatio(devicePixelRatio);
    renderer.setSize(innerWidth, innerHeight);
    canvasParent.appendChild(renderer.domElement);

    // Controles tipo "free-fly" con mouse look
    const controls = new PointerLockControls(camera, renderer.domElement);
    scene.add(controls.getObject());
    const ui = document.getElementById("ui");
    ui.addEventListener("click", () => controls.lock());
    controls.addEventListener("lock", () => ui.style.display = "none");
    controls.addEventListener("unlock", () => ui.style.display = "");

    // Iluminación sutil
    const hemi = new THREE.HemisphereLight(0x88ccff, 0x080820, 0.6);
    scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xffffff, 0.6);
    dir.position.set(1, 2, 1);
    scene.add(dir);

    // "Habitación" cúbica vista desde adentro
    const roomSize = 80;
    const roomGeo = new THREE.BoxGeometry(roomSize, roomSize, roomSize);
    const roomMat = new THREE.MeshStandardMaterial({
      color: 0x0a0f24,
      side: THREE.BackSide,
      metalness: 0.1,
      roughness: 0.9
    });
    const room = new THREE.Mesh(roomGeo, roomMat);
    scene.add(room);

    const edges = new THREE.LineSegments(
      new THREE.EdgesGeometry(roomGeo),
      new THREE.LineBasicMaterial({ transparent:true, opacity:0.15 })
    );
    scene.add(edges);

    const gridSize = roomSize;
    const divisions = 20;
    const gridColor1 = 0xCCCCCC;
    const gridColor2 = 0x888888;

    const floorGrid = new THREE.GridHelper(gridSize, divisions, gridColor1, gridColor2);
    floorGrid.position.y = -roomSize/2;
    scene.add(floorGrid);

    const ceilingGrid = new THREE.GridHelper(gridSize, divisions, gridColor1, gridColor2);
    ceilingGrid.rotation.x = Math.PI;
    ceilingGrid.position.y = roomSize/2;
    scene.add(ceilingGrid);

    const backWallGrid = new THREE.GridHelper(gridSize, divisions, gridColor1, gridColor2);
    backWallGrid.rotation.x = Math.PI / 2;
    backWallGrid.position.z = -roomSize/2;
    scene.add(backWallGrid);

    const frontWallGrid = new THREE.GridHelper(gridSize, divisions, gridColor1, gridColor2);
    frontWallGrid.rotation.x = -Math.PI / 2;
    frontWallGrid.position.z = roomSize/2;
    scene.add(frontWallGrid);

    const leftWallGrid = new THREE.GridHelper(gridSize, divisions, gridColor1, gridColor2);
    leftWallGrid.rotation.z = Math.PI / 2;
    leftWallGrid.rotation.y = Math.PI / 2;
    leftWallGrid.position.x = -roomSize/2;
    scene.add(leftWallGrid);

    const rightWallGrid = new THREE.GridHelper(gridSize, divisions, gridColor1, gridColor2);
    rightWallGrid.rotation.z = -Math.PI / 2;
    rightWallGrid.rotation.y = -Math.PI / 2;
    rightWallGrid.position.x = roomSize/2;
    scene.add(rightWallGrid);

    // Objetos flotantes
    const group = new THREE.Group();
    scene.add(group);

    const rnd = (a,b)=> a + Math.random()*(b-a);
    const floaters = [];
    const structures = []; // Almacenar información de estructuras
    const sphereMat = new THREE.MeshStandardMaterial({ color: 0x66ccff, metalness:0.4, roughness:0.2, emissive:0x001122, emissiveIntensity:0.3, transparent:true });
    const boxMat    = new THREE.MeshStandardMaterial({ color: 0xffbb55, metalness:0.2, roughness:0.6, emissive:0x221100, emissiveIntensity:0.2, transparent:true });

    for (let i=0;i<40;i++){
      const isSphere = Math.random()>0.5;
      const size = isSphere ? rnd(0.6,2.2) : rnd(0.8,2.5);
      const geo = isSphere ? new THREE.SphereGeometry(size, 24, 16)
                           : new THREE.BoxGeometry(size, size, size);
      const mat = isSphere ? sphereMat.clone() : boxMat.clone();
      mat.opacity = 0.9; // Opacidad inicial
      const hsl = { h: 0, s: 0, l: 0 };
      mat.color.getHSL(hsl);
      hsl.h += Math.random()*0.2-0.1;
      hsl.s += Math.random()*0.2-0.1;
      hsl.l += Math.random()*0.2-0.1;
      mat.color.setHSL(hsl.h, hsl.s, hsl.l);
      const m = new THREE.Mesh(geo, mat);
      m.position.set(rnd(-roomSize/2+5, roomSize/2-5),
                     rnd(-roomSize/2+5, roomSize/2-5),
                     rnd(-roomSize/2+5, roomSize/2-5));
      group.add(m);
      floaters.push(m);
      
      // Almacenar información de la estructura
      structures.push({
        mesh: m,
        isSphere: isSphere,
        size: size,
        originalOpacity: 0.9
      });
    }

    const fontLoader = new FontLoader();
    fontLoader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', (font) => {
      const textGeometry = new TextGeometry('OmartLabs', {
        font: font,
        size: 4,
        height: 0.5,
        curveSegments: 12,
        bevelEnabled: true,
        bevelThickness: 0.1,
        bevelSize: 0.1,
        bevelOffset: 0,
        bevelSegments: 5
      });
      textGeometry.computeBoundingBox();
      const textMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x66ccff, 
        metalness: 0.6, 
        roughness: 0.3,
        emissive: 0x001133,
        emissiveIntensity: 0.4,
        transparent: true
      });
      textMaterial.opacity = 0.9;
      const textMesh = new THREE.Mesh(textGeometry, textMaterial);
      const centerOffset = -0.5 * (textGeometry.boundingBox.max.x - textGeometry.boundingBox.min.x);
      textMesh.position.set(centerOffset, 10, -roomSize/2 + 5);
      group.add(textMesh);
      
      // Agregar texto como estructura interactiva
      const bbox = textGeometry.boundingBox;
      const textWidth = bbox.max.x - bbox.min.x;
      const textHeight = bbox.max.y - bbox.min.y;
      const textDepth = bbox.max.z - bbox.min.z;
      structures.push({
        mesh: textMesh,
        isSphere: false, // Tratarlo como cubo para límites
        size: Math.max(textWidth, textHeight, textDepth) * 1.2, // Aumentar un poco para mejor entrada
        sizeX: textWidth,
        sizeY: textHeight,
        sizeZ: textDepth,
        originalOpacity: 0.9
      });
    });

    // Movimiento libre (WASD + Flechas + Space/Shift)
    const keys = new Set();
    addEventListener('keydown', e=> keys.add(e.code));
    addEventListener('keyup',   e=> keys.delete(e.code));

    let last = performance.now();
    let currentStructure = null; // Estructura dentro de la cual estamos
    
    function tick(now){
      const dt = Math.min(0.05, (now - last)/1000);
      last = now;

      if (controls.isLocked) {
        const moveObject = controls.getObject();
        const cameraPos = moveObject.position;
        
        // Detectar proximidad a estructuras
        let closestStructure = null;
        let closestDistance = Infinity;
        const enterThreshold = 3.0; // Distancia para entrar
        const exitThreshold = 4.0; // Distancia para salir (más grande para evitar flickering)
        
        structures.forEach(structure => {
          const structPos = structure.mesh.position;
          const distance = cameraPos.distanceTo(structPos);
          const size = structure.size;
          
          // Calcular si estamos dentro de la estructura
          let isInside = false;
          if (structure.isSphere) {
            // Para esfera: distancia al centro < radio
            isInside = distance < size + 0.5; // +0.5 margen para entrada suave
          } else {
            // Para cubo: verificar si estamos dentro del bounding box
            let boxSizeX = size, boxSizeY = size, boxSizeZ = size;
            if (structure.sizeX) {
              boxSizeX = structure.sizeX;
              boxSizeY = structure.sizeY;
              boxSizeZ = structure.sizeZ;
            }
            const dx = Math.abs(cameraPos.x - structPos.x);
            const dy = Math.abs(cameraPos.y - structPos.y);
            const dz = Math.abs(cameraPos.z - structPos.z);
            isInside = dx < boxSizeX/2 + 0.5 && dy < boxSizeY/2 + 0.5 && dz < boxSizeZ/2 + 0.5;
          }
          
          // Ajustar transparencia basada en distancia
          const proximityFactor = Math.max(0, Math.min(1, (distance - size) / enterThreshold));
          if (distance < size + enterThreshold) {
            structure.mesh.material.opacity = 0.3 + 0.6 * proximityFactor; // Más transparente cuando cerca
          } else {
            structure.mesh.material.opacity = structure.originalOpacity;
          }
          
          // Detectar estructura más cercana
          if (isInside && distance < closestDistance) {
            closestDistance = distance;
            closestStructure = structure;
          }
        });
        
        // Actualizar estructura actual
        if (closestStructure && (!currentStructure || closestStructure !== currentStructure)) {
          currentStructure = closestStructure;
        } else if (!closestStructure && currentStructure) {
          // Verificar si todavía estamos dentro de la estructura actual
          const structPos = currentStructure.mesh.position;
          const distance = cameraPos.distanceTo(structPos);
          let stillInside = false;
          
          if (currentStructure.isSphere) {
            stillInside = distance < currentStructure.size + exitThreshold;
          } else {
            let boxSizeX = currentStructure.size;
            let boxSizeY = currentStructure.size;
            let boxSizeZ = currentStructure.size;
            if (currentStructure.sizeX) {
              boxSizeX = currentStructure.sizeX;
              boxSizeY = currentStructure.sizeY;
              boxSizeZ = currentStructure.sizeZ;
            }
            const dx = Math.abs(cameraPos.x - structPos.x);
            const dy = Math.abs(cameraPos.y - structPos.y);
            const dz = Math.abs(cameraPos.z - structPos.z);
            stillInside = dx < boxSizeX/2 + exitThreshold && dy < boxSizeY/2 + exitThreshold && dz < boxSizeZ/2 + exitThreshold;
          }
          
          if (!stillInside) {
            currentStructure = null;
          }
        }
        
        const direction = new THREE.Vector3();
        const forward = new THREE.Vector3(0, 0, -1);
        const right = new THREE.Vector3(1, 0, 0);
        const up = new THREE.Vector3(0, 1, 0);
        forward.applyQuaternion(moveObject.quaternion);
        right.applyQuaternion(moveObject.quaternion);
        
        const speed = 10;
        // Movimiento hacia adelante (W o Flecha Arriba)
        if (keys.has('KeyW') || keys.has('ArrowUp')) {
          direction.add(forward);
        }
        // Movimiento hacia atrás (S o Flecha Abajo)
        if (keys.has('KeyS') || keys.has('ArrowDown')) {
          direction.addScaledVector(forward, -1);
        }
        // Movimiento hacia la izquierda (A o Flecha Izquierda)
        if (keys.has('KeyA') || keys.has('ArrowLeft')) {
          direction.addScaledVector(right, -1);
        }
        // Movimiento hacia la derecha (D o Flecha Derecha)
        if (keys.has('KeyD') || keys.has('ArrowRight')) {
          direction.add(right);
        }
        // Movimiento hacia arriba (Space)
        if (keys.has('Space')) {
          direction.add(up);
        }
        // Movimiento hacia abajo (Shift o Control)
        if (keys.has('ShiftLeft') || keys.has('ShiftRight') || keys.has('ControlLeft') || keys.has('ControlRight')) {
          direction.addScaledVector(up, -1);
        }
        
        if (direction.lengthSq() > 0) {
          direction.normalize().multiplyScalar(speed * dt);
          moveObject.position.add(direction);
          const p = moveObject.position;
          
          // Límites dinámicos: si estamos dentro de una estructura, usar sus límites
          if (currentStructure) {
            const structPos = currentStructure.mesh.position;
            const structSize = currentStructure.size;
            const margin = 0.3; // Margen para evitar salir accidentalmente
            
            if (currentStructure.isSphere) {
              // Límites esféricos: mantener dentro del radio
              const distFromCenter = p.distanceTo(structPos);
              if (distFromCenter > structSize - margin) {
                const directionOut = new THREE.Vector3().subVectors(p, structPos).normalize();
                p.copy(structPos).add(directionOut.multiplyScalar(structSize - margin));
              }
            } else {
              // Límites de cubo: mantener dentro del bounding box
              let halfX = structSize / 2 - margin;
              let halfY = structSize / 2 - margin;
              let halfZ = structSize / 2 - margin;
              
              // Usar tamaños específicos si están disponibles (para texto)
              if (currentStructure.sizeX) {
                halfX = currentStructure.sizeX / 2 - margin;
                halfY = currentStructure.sizeY / 2 - margin;
                halfZ = currentStructure.sizeZ / 2 - margin;
              }
              
              p.x = THREE.MathUtils.clamp(p.x, structPos.x - halfX, structPos.x + halfX);
              p.y = THREE.MathUtils.clamp(p.y, structPos.y - halfY, structPos.y + halfY);
              p.z = THREE.MathUtils.clamp(p.z, structPos.z - halfZ, structPos.z + halfZ);
            }
          } else {
            // Límites normales del cuarto
            const half = roomSize/2 - 2;
            p.x = THREE.MathUtils.clamp(p.x, -half, half);
            p.y = THREE.MathUtils.clamp(p.y, -half, half);
            p.z = THREE.MathUtils.clamp(p.z, -half, half);
          }
        }
      }

      renderer.render(scene, camera);
      requestAnimationFrame(tick);
    }
    requestAnimationFrame(tick);

    // Resize
    addEventListener('resize', ()=>{
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });
  </script>
</body>
</html>
