<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <title>Cubo 3D con objetos flotando</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
  </script>
  <style>
    html, body { margin:0; height:100%; overflow:hidden; background:#000; }
    #ui {
      position:fixed; inset:0; display:grid; place-items:center;
      pointer-events:none; color:#fff; font:16px system-ui;
      background: radial-gradient(ellipse at center, #0008 0%, #0000 60%);
    }
    #hint {
      pointer-events:auto; padding:12px 16px; border:1px solid #fff3; border-radius:10px; 
      background:#111a; backdrop-filter: blur(4px);
    }
  </style>
</head>
<body>
  <div id="ui"><div id="hint">Click para entrar • Flechas para moverse • Esc para soltar</div></div>

  <script type="module">
    import * as THREE from "three";
    import { PointerLockControls } from "three/addons/controls/PointerLockControls.js";
    import { TextGeometry } from "three/addons/geometries/TextGeometry.js";
    import { FontLoader } from "three/addons/loaders/FontLoader.js";

    const canvasParent = document.body;
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000010, 0.02);

    const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
    camera.position.set(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ antialias:true });
    renderer.setPixelRatio(devicePixelRatio);
    renderer.setSize(innerWidth, innerHeight);
    canvasParent.appendChild(renderer.domElement);

    // Controles tipo "free-fly" con mouse look
    const controls = new PointerLockControls(camera, renderer.domElement);
    scene.add(controls.getObject());
    const ui = document.getElementById("ui");
    ui.addEventListener("click", () => controls.lock());
    controls.addEventListener("lock", () => ui.style.display = "none");
    controls.addEventListener("unlock", () => ui.style.display = "");

    // Iluminación sutil
    const hemi = new THREE.HemisphereLight(0x88ccff, 0x080820, 0.6);
    scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xffffff, 0.6);
    dir.position.set(1, 2, 1);
    scene.add(dir);

    // "Habitación" cúbica vista desde adentro
    const roomSize = 80;
    const roomGeo = new THREE.BoxGeometry(roomSize, roomSize, roomSize);
    const roomMat = new THREE.MeshStandardMaterial({
      color: 0x0a0f24,
      side: THREE.BackSide,
      metalness: 0.1,
      roughness: 0.9
    });
    const room = new THREE.Mesh(roomGeo, roomMat);
    scene.add(room);

    const edges = new THREE.LineSegments(
      new THREE.EdgesGeometry(roomGeo),
      new THREE.LineBasicMaterial({ transparent:true, opacity:0.15 })
    );
    scene.add(edges);

    const gridSize = roomSize;
    const divisions = 20;
    const gridColor1 = 0x888888;
    const gridColor2 = 0x444444;

    const floorGrid = new THREE.GridHelper(gridSize, divisions, gridColor1, gridColor2);
    floorGrid.position.y = -roomSize/2;
    scene.add(floorGrid);

    const ceilingGrid = new THREE.GridHelper(gridSize, divisions, gridColor1, gridColor2);
    ceilingGrid.rotation.x = Math.PI;
    ceilingGrid.position.y = roomSize/2;
    scene.add(ceilingGrid);

    const backWallGrid = new THREE.GridHelper(gridSize, divisions, gridColor1, gridColor2);
    backWallGrid.rotation.x = Math.PI / 2;
    backWallGrid.position.z = -roomSize/2;
    scene.add(backWallGrid);

    const frontWallGrid = new THREE.GridHelper(gridSize, divisions, gridColor1, gridColor2);
    frontWallGrid.rotation.x = -Math.PI / 2;
    frontWallGrid.position.z = roomSize/2;
    scene.add(frontWallGrid);

    const leftWallGrid = new THREE.GridHelper(gridSize, divisions, gridColor1, gridColor2);
    leftWallGrid.rotation.z = Math.PI / 2;
    leftWallGrid.rotation.y = Math.PI / 2;
    leftWallGrid.position.x = -roomSize/2;
    scene.add(leftWallGrid);

    const rightWallGrid = new THREE.GridHelper(gridSize, divisions, gridColor1, gridColor2);
    rightWallGrid.rotation.z = -Math.PI / 2;
    rightWallGrid.rotation.y = -Math.PI / 2;
    rightWallGrid.position.x = roomSize/2;
    scene.add(rightWallGrid);

    // Objetos flotantes
    const group = new THREE.Group();
    scene.add(group);

    const rnd = (a,b)=> a + Math.random()*(b-a);
    const floaters = [];
    const sphereMat = new THREE.MeshStandardMaterial({ color: 0x66ccff, metalness:0.4, roughness:0.2, emissive:0x001122, emissiveIntensity:0.3 });
    const boxMat    = new THREE.MeshStandardMaterial({ color: 0xffbb55, metalness:0.2, roughness:0.6, emissive:0x221100, emissiveIntensity:0.2 });

    for (let i=0;i<40;i++){
      const isSphere = Math.random()>0.5;
      const geo = isSphere ? new THREE.SphereGeometry(rnd(0.6,2.2), 24, 16)
                           : new THREE.BoxGeometry(rnd(0.8,2.5), rnd(0.8,2.5), rnd(0.8,2.5));
      const mat = isSphere ? sphereMat.clone() : boxMat.clone();
      const hsl = { h: 0, s: 0, l: 0 };
      mat.color.getHSL(hsl);
      hsl.h += Math.random()*0.2-0.1;
      hsl.s += Math.random()*0.2-0.1;
      hsl.l += Math.random()*0.2-0.1;
      mat.color.setHSL(hsl.h, hsl.s, hsl.l);
      const m = new THREE.Mesh(geo, mat);
      m.position.set(rnd(-roomSize/2+5, roomSize/2-5),
                     rnd(-roomSize/2+5, roomSize/2-5),
                     rnd(-roomSize/2+5, roomSize/2-5));
      group.add(m);
      floaters.push(m);
    }

    const fontLoader = new FontLoader();
    fontLoader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', (font) => {
      const textGeometry = new TextGeometry('OmartLabs', {
        font: font,
        size: 4,
        height: 0.5,
        curveSegments: 12,
        bevelEnabled: true,
        bevelThickness: 0.1,
        bevelSize: 0.1,
        bevelOffset: 0,
        bevelSegments: 5
      });
      textGeometry.computeBoundingBox();
      const textMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x66ccff, 
        metalness: 0.6, 
        roughness: 0.3,
        emissive: 0x001133,
        emissiveIntensity: 0.4
      });
      const textMesh = new THREE.Mesh(textGeometry, textMaterial);
      const centerOffset = -0.5 * (textGeometry.boundingBox.max.x - textGeometry.boundingBox.min.x);
      textMesh.position.set(centerOffset, 10, -roomSize/2 + 5);
      group.add(textMesh);
    });

    // Movimiento libre (WASD + Space/Shift)
    const keys = new Set();
    addEventListener('keydown', e=> keys.add(e.code));
    addEventListener('keyup',   e=> keys.delete(e.code));

    let last = performance.now();
    function tick(now){
      const dt = Math.min(0.05, (now - last)/1000);
      last = now;

      if (controls.isLocked) {
        const moveObject = controls.getObject();
        const direction = new THREE.Vector3();
        const forward = new THREE.Vector3(0, 0, -1);
        const right = new THREE.Vector3(1, 0, 0);
        forward.applyQuaternion(moveObject.quaternion);
        right.applyQuaternion(moveObject.quaternion);
        
        const speed = 10;
        if (keys.has('ArrowUp')) {
          direction.add(forward);
        }
        if (keys.has('ArrowDown')) {
          direction.addScaledVector(forward, -1);
        }
        if (keys.has('ArrowLeft')) {
          direction.addScaledVector(right, -1);
        }
        if (keys.has('ArrowRight')) {
          direction.add(right);
        }
        
        if (direction.lengthSq() > 0) {
          direction.normalize().multiplyScalar(speed * dt);
          moveObject.position.add(direction);
          const p = moveObject.position;
          const half = roomSize/2 - 2;
          p.x = THREE.MathUtils.clamp(p.x, -half, half);
          p.y = THREE.MathUtils.clamp(p.y, -half, half);
          p.z = THREE.MathUtils.clamp(p.z, -half, half);
        }
      }

      renderer.render(scene, camera);
      requestAnimationFrame(tick);
    }
    requestAnimationFrame(tick);

    // Resize
    addEventListener('resize', ()=>{
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });
  </script>
</body>
</html>
